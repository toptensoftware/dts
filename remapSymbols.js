import path from 'node:path';
import ts from 'typescript';
import { isDeclarationNode } from './utils.js';
import { MappedSource, EditableMappedSource } from "@toptensoftware/mapped-source";
import { escapeRegExp } from './utils.js';

let lastOriginalFileName = null;
let lastOriginalFile;
function loadOriginalFile(sourceFileName)
{
    if (lastOriginalFileName == sourceFileName)
        return lastOriginalFile;

    lastOriginalFileName = sourceFileName;
    lastOriginalFile = MappedSource.fromFile(sourceFileName);
    return lastOriginalFile;
}


function regExpForName(name) {
    let rx = "";
    if (!name.startsWith("$"))
        rx += "\\b";
    rx += escapeRegExp(name);
    if (!name.endsWith("$"))
        rx += "\\b";
    return rx;
}


/**
 * Creates a source map for a file by walking the ast, finding all declaraion
 * names and mapping them to either the the position in the file, or if the 
 * file has a source mapping itself, to what ever it maps to.
 * 
 * Because the .map files generated by tsc can be a bit out of whack, when
 * looking up an existing source map starts at mapped line and scans forward
 * for the symbol name to get a precise location
 * 
 * @param {MappedSource} source The source file
 * @param {any} ast The parsed typescript ast of the file
 */
export function remapSymbols(source, ast)
{
    // Get base directory for relative path names
    let relbase = path.dirname(path.resolve(source.filename));

    // Start with just the source code
    let map = [];
    ts.forEachChild(ast, walk);
    return new EditableMappedSource(source.code, map);

    function walk(node)
    {
        if (isDeclarationNode(node) && node.name && node.kind != ts.SyntaxKind.ModuleDeclaration)
        {
            // Get the name and its position
            let name = node.name.getText();
            let nameOffset = node.name.getStart();

            // Ignore private fields
            if (name.startsWith("#"))
                return;

            // Find the original position
            let namepos = source.lineMap.fromOffset(nameOffset);

            let mapped = false;
            if (source.sourceMap)
            {
                let originalPos = source.sourceMap.originalPositionFor(namepos);
                if (originalPos.source)
                {
                    let originalSource = originalPos.source;

                    // Load the original file
                    let originalSourceFile = loadOriginalFile(path.join(relbase, originalPos.source));

                    // Look for the symbol

                    // Searching from the start of the line instead of the original position column
                    // helps this works for cases like where name is before the declaration eg:  "{ name: function () }"
                    // In these cases the originalPos.column is after "name"
                    let originalOffsetStart = originalSourceFile.lineMap.toOffset(originalPos.line, 0);//originalPos.column);

                    let rx = new RegExp(regExpForName(name), 'g');
                    rx.lastIndex = originalOffsetStart;
                    let m = rx.exec(originalSourceFile.code);
                    if (m)
                    {
                        originalOffsetStart = m.index;
                        originalPos = originalSourceFile.lineMap.fromOffset(originalOffsetStart);
                        
                        // Start of name
                        map.push({
                            offset: nameOffset,
                            name: name,
                            source: originalSource,
                            originalLine: originalPos.line,
                            originalColumn: originalPos.column,
                        });

                        // End of name
                        map.push({
                            offset: nameOffset + name.length,
                            name: name,
                            source: originalSource,
                            originalLine: originalPos.line,
                            originalColumn: originalPos.column + name.length,
                        });

                        mapped = true;
                    }
                }
            }

            // Create mapping to self
            if (!mapped)
            {
                // Start of name
                map.push({
                    offset: nameOffset,
                    name: name,
                    source: source.filename,
                    originalLine: namepos.line,
                    originalColumn: namepos.column,
                });

                // End of name
                map.push({
                    offset: nameOffset + name.length,
                    name: name,
                    source: source.filename,
                    originalLine: namepos.line,
                    originalColumn: namepos.column + name.length,
                });
            }
        }

        // Recurse
        ts.forEachChild(node, walk);
    }

}